#!/usr/bin/env python3
# -*- coding: utf-8 -*-
r"""
================================================================
Descriptor calculation routines (:mod:`polipy4vasp.descriptors`)
================================================================

.. currentmodule:: polipy4vasp.descriptors
    
"""


import numpy as np
from dataclasses import dataclass
from joblib import Parallel, delayed

from .sph import sph_harm
from .positions import conf2nn_conf
from .tensor_descriptors import get_ten_p

@dataclass
class Descriptor:
    r'''
    Dataclass containing the descripror, its deriverive, and al vital information for describing the data
    structure.
    
    args:
        lc (list) : The local configurations :math:`\textbf{X}_i`.
        dc (list) : Derivertives of expanssion coefficents :math:`\frac{\mathrm{d}}{\mathrm{d}r^\alpha_i}c^{jJ}_{nlm}`.
        self_dc (list) : Derivertives of expanssion coefficents :math:`\frac{\mathrm{d}}{\mathrm{d}r^\alpha_i}c^{iJ}_{nlm}`.
        dp (list) : Array of derivertives of the three body expansions coefficients :math:`\frac{\mathrm{d}}{\mathrm{d} c^{jJ}_{nlm}}p^{iJJ'}_{nn'l}`.
        natom (int) : Number of atoms.
        centraltype (list) : Type of the central atom.
        derivtype (list) : Atom type of non zero derivertive.
        derivl (list) : Derivertive list.
        derivloc (list) : List containing the location of non zero derivertivs.
        maxderiv (int) : Maximal number of  nearest neighbors.
        maxtype (int) : Maximal number of types.
        llc (list) : The linear (:math:`\lambda=0`) local configurations :math:`\textbf{X}_i`. Only used for :math:`\lambda>0` and :math:`\zeta>1`.
        
    notes:
        The nearest neighbors are needed for the derivertives, since all other atom derivertives are zero only
        those in the nearest neighbor list are stored.
        
    '''
    lc : list
    dc : list
    self_dc : list
    dp : list
    natom : int
    centraltype : list
    derivtype : list
    derivl : list
    derivloc : list
    maxderiv : int
    maxtype : int
    llc : list
    
    def __eq__(self,descriptor):
        r'''
        Checkes if two Descriptor are equal.

        Parameters
        ----------
        descriptor : Descriptor
            Class containing the local configuration, its derivertive, and all necercery information for unraveling the data structure

        Returns
        -------
        bool
            Returns ``True`` if the two descriptors are equal.

        '''
        for a, b in zip(self.lc,descriptor.lc):
            if not np.all(a == b) :
                print('lc')
                return False
        for a, b in zip(self.self_dc,descriptor.self_dc):
            if not np.all(a == b) :
                print('self_dc')
                return False
        for a, b in zip(self.dp,descriptor.dp):
            if not np.all(a == b) :
                print('dp')
                return False
        for a, b in zip(self.centraltype,descriptor.centraltype):
            if not np.all(a == b) :
                print('centraltype')
                return False
        for a, b in zip(self.derivtype,descriptor.derivtype):
            if not np.all(a == b) :
                print('derivtyper')
                return False
        for a, b in zip(self.derivl,descriptor.derivl):
            if not np.all(a == b) :
                print('derivl')
                return False
        if self.llc == None :
            if self.llc != descriptor.llc:
                return False
        else :
            for a, b in zip(self.llc,descriptor.llc):
                if not np.all(a == b) :
                    return False
        if self.maxderiv != descriptor.maxderiv :
            return False
        if self.maxtype != descriptor.maxtype :
            return False
        if self.natom != descriptor.natom :
            return False
        return True
        


def get_cTilde(settings,nnconf,h):
    r'''
    This routine calculates the pair expansion coefficients :math:`\tilde{c}^{ij}_{nlm}` defined as
    
    .. math:: \tilde{c}^{ij}_{nlm} = Y_{lm}(\hat{\textbf{r}}_{ij}) h_{nl}(r_{ij}),
    
    and its derivertive
    
    .. math:: \frac{\mathrm{d}}{\mathrm{d}r^\alpha_i} \tilde{c}^{ij}_{nlm} = -\left(\frac{\mathrm{d}}{\mathrm{d}r^\alpha_i}Y_{lm}(\hat{\textbf{r}}_{ij})\right) h_{nl}(r_{ij}) + Y_{lm}(\hat{\textbf{r}}_{ij})\left(\frac{\mathrm{d}}{\mathrm{d}r_{ij}}h_{nl}(r_{ij})\right)\frac{r_i^\alpha-r_j^\alpha}{r_{ij}}.
    
    Arguments
    ---------
    settings : Setup
        Class containing all the user defined settings for training the MLFF
    nnconf : NN_Configuration
        Class containing the information of a configuration in a nearest neighbor sense
    h : CubicSpline
        Cubic spline function generated by :func:`polipy4vasp.splines.get_splines`
    
    Returns
    -------
    cTilde : ndarray
        Array of pair expansion coefficients :math:`\tilde{c}^{ij}_{nlm}`
    dcTilde : ndarray
        Array of the derivertive of pair expansion coefficients :math:`\frac{\mathrm{d}}{\mathrm{d}r^\alpha_i}\tilde{c}^{ij}_{nlm}`
    '''
    drij = nnconf.nnvecr/nnconf.nnr[:,:,np.newaxis]
    Y, dY = sph_harm(settings.Lmax,drij)
    dY = dY/nnconf.nnr[np.newaxis,:,:,np.newaxis]
    shnl = h(nnconf.nnr)
    sdhnl = h(nnconf.nnr,1)[:,:,:,:,np.newaxis]*drij[np.newaxis,np.newaxis,:,:,:]
    hnl = np.empty([settings.Nmax,(settings.Lmax+1)*(settings.Lmax+1),nnconf.natom,nnconf.maxnn])
    dhnl = np.empty([settings.Nmax,(settings.Lmax+1)*(settings.Lmax+1),nnconf.natom,nnconf.maxnn,3])
    for l in range(settings.Lmax+1):
        hnl[:,l*l:(l+1)*(l+1),:,:] = shnl[:,l,:,:][:,np.newaxis,:,:]
        dhnl[:,l*l:(l+1)*(l+1),:,:,:] = sdhnl[:,l,:,:,:][:,np.newaxis,:,:,:]
    cTilde = Y[np.newaxis,:,:,:]*hnl
    dcTilde = Y[np.newaxis,:,:,:,np.newaxis]*dhnl+dY[np.newaxis,:,:,:,:]*hnl[:,:,:,:,np.newaxis]
    return cTilde, dcTilde

def get_c(settings,nnconf,cTilde,dcTilde):
    r'''
    This routine calculates the expansions coefficients :math:`c^{iJ}_{nlm}` defined as
    
    .. math:: c^{iJ}_{nlm} = \sum_{\substack{j\neq i \\ j\in J}}\tilde{c}^{ij}_{nlm},
    
    where :math:`J` indicates the species of the interacting atom. Also the derivertive is calculated
    
    .. math:: \frac{\mathrm{d}}{\mathrm{d} r_k^\alpha}c^{iJ}_{nlm}&=\sum_{\substack{j\neq i \\ j\in J}}\left(\frac{\mathrm{d}}{\mathrm{d} r_k^\alpha}\tilde{c}^{ij}_{nlm}\right),
    
    with the index :math:`k` indecating ether the central atom or a nearest neighbor.
    
    Arguments
    ---------
    settings : Setup
        Class containing all the user defined settings for training the MLFF
    nnconf : NN_Configuration
        Class containing the information of a configuration in a nearest neighbor sense
    cTilde : ndarray
        Array of pair radial expansion coefficients :math:`\tilde{c}^{ij}_{nlm}`
    dcTilde : ndarray
        Array of the derivertives of pair radial expansion coefficients :math:`\frac{\mathrm{d}}{\mathrm{d}r^\alpha_i}\tilde{c}^{ij}_{nlm}`
    
    Returns
    -------
    c : ndarray
        Array of expanssion coefficents :math:`c^{iJ}_{nlm}`
    dc : ndarray
        Array of derivertives of expanssion coefficents :math:`\frac{\mathrm{d}}{\mathrm{d}r^\alpha_i}c^{jJ}_{nlm}`
    self_dc : ndarray
        Array of derivertives of expanssion coefficents :math:`\frac{\mathrm{d}}{\mathrm{d}r^\alpha_i}c^{iJ}_{nlm}`
    nndo : list
        List of bool arrays for selekting atom nearest neighbor types
    '''
    c = np.zeros([settings.Nmax,(settings.Lmax+1)*(settings.Lmax+1),nnconf.maxtype,nnconf.natom])
    self_dc = np.zeros([settings.Nmax,(settings.Lmax+1)*(settings.Lmax+1),nnconf.maxtype,nnconf.natom,3])
    nndo = []
    for J in range(nnconf.maxtype):
        ntypemask = nnconf.nntype == J
        for i, do in enumerate(ntypemask):
            c[:,:,J,i] = np.sum(cTilde[:,:,i,do],axis=-1)
            self_dc[:,:,J,i,:] = -np.sum(dcTilde[:,:,i,do,:],axis=-2)       
        nndo.append(ntypemask)
    if nnconf.mult_per_img :
        mask = ~np.eye(nnconf.natom, dtype=bool)
        nnconf.nnn = np.ones(nnconf.natom,dtype = np.int32)*(nnconf.natom-1)
        buf_nnl = (np.arange(nnconf.natom,dtype = np.int32)[np.newaxis,:]*np.ones(nnconf.natom,dtype = np.int32)[:,np.newaxis])[mask].reshape(nnconf.natom,-1)
        nnconf.nntype = (nnconf.centraltype[np.newaxis,:]*np.ones(nnconf.natom)[:,np.newaxis])[mask].reshape(nnconf.natom,-1)
        dc = np.zeros([settings.Nmax,(settings.Lmax+1)*(settings.Lmax+1),nnconf.natom,nnconf.natom-1,3])
        for j in range(nnconf.natom) :
            for i in range(nnconf.natom-1) :
                dc[:,:,j,i,:] = np.sum(dcTilde[:,:,j,nnconf.nnl[j] == buf_nnl[j][i],:], axis = 2)
        nnconf.nnl = buf_nnl
        nndo = [nnconf.nntype == J for J in range(nnconf.maxtype)]
    else :
        dc = dcTilde #sym_fac*dcTilde
    return c, dc, self_dc, nndo

def get_p(settings,glob,nnconf,c):
    r'''
    This routine calculates the three body expansions coefficients :math:`p^{iJJ'}_{nn'l}` defined as
    
    .. math:: p^{iJJ'}_{nn'l} = \sqrt{\frac{8\pi^2}{2l+1}}\sum_{m=-l}^{l}\left[c^{iJ}_{nlm}c^{iJ'}_{n'lm}-\delta_{JJ'}\sum_{\substack{j\neq i \\ j\in J}}\tilde{c}^{ij}_{nlm}\tilde{c}^{ij}_{n'lm}\right],
    
    and its derivative with respect to :math:`c^{iJ}_{nlm}`.

    Arguments
    ---------
    settings : Setup
        Class containing all the user defined settings for training the MLFF
    glob : Globals
        Class containing all precomputet coefficients
    nnconf : NN_Configuration
        Class containing the information of a configuration in a nearest neighbor sense
    c : ndarray
        Array of expanssion coefficients :math:`c^{iJ}_{nlm}`

    Returns
    -------
    p : ndarray
        Array of the three body expansions coefficients :math:`p^{iJJ'}_{nn'l}`
    dp: ndarray
        Array of derivertives of the three body expansions coefficients :math:`\frac{\mathrm{d}}{\mathrm{d} c^{jJ}_{nlm}}p^{iJJ'}_{nn'l}`
    '''
    buf = np.multiply(c[:,np.newaxis,:,:,np.newaxis,:],c[np.newaxis,:,:,np.newaxis,:,:])
    p = np.empty([settings.Nmax,settings.Nmax,settings.Lmax+1,nnconf.maxtype,nnconf.maxtype,nnconf.natom])
    dp = np.empty_like(c)
    for l in range(settings.Lmax+1):
        p[:,:,l,:,:,:] = np.sum(buf[:,:,l*l:(l+1)*(l+1),:,:,:],axis=2)
        dp[:,l*l:(l+1)*(l+1),:,:]=glob.fac[0,l,0,0]*c[:,l*l:(l+1)*(l+1),:,:]
    p = glob.fac[np.newaxis,:,:,:,:,np.newaxis]*p
    return p, dp

def nnconf_H2O(nnconf, atomname = ['H', 'O']):
    # set up new arrays
    nnl    = np.empty((nnconf.natom, 2), dtype=np.int32)
    nnr    = np.empty((nnconf.natom, 2))
    nnvecr = np.empty((nnconf.natom, 2, 3))
    nntype = np.empty((nnconf.natom, 2), dtype=np.int32)

    # central O
    Ht = np.argwhere(np.array(atomname) == 'H')[0,0]
    Omask = np.squeeze(np.argwhere(nnconf.centraltype == np.argwhere(np.array(atomname) == 'O')[0,0]))
    nntype[Omask] = Ht
    for i, tp in enumerate(nnconf.nntype[Omask]):
        mask = tp == Ht
        s = np.argsort(nnconf.nnr[Omask[i],mask])[:2]
        nnl[Omask[i]]    = nnconf.nnl[Omask[i],mask][s]
        nntype[Omask[i]] = nnconf.nntype[Omask[i],mask][s]
        nnr[Omask[i]]    = nnconf.nnr[Omask[i],mask][s]
        nnvecr[Omask[i]] = nnconf.nnvecr[Omask[i],mask][s]

    # central H
    Ot = np.argwhere(np.array(atomname) == 'O')[0,0]
    Hmask = np.squeeze(np.argwhere(nnconf.centraltype == np.argwhere(np.array(atomname) == 'H')[0,0]))
    nntype[Hmask, 0] = Ot
    nntype[Hmask, 1] = Ht
    for i, tp in enumerate(nnconf.nntype[Hmask]):
        mask = tp == Ot
        s = np.argsort(nnconf.nnr[Hmask][i,mask])[0]
        nnl[Hmask[i],0]    = nnconf.nnl[Hmask][i,mask][s]
        nntype[Hmask[i],0] = nnconf.nntype[Hmask][i,mask][s]
        nnr[Hmask[i],0]    = nnconf.nnr[Hmask][i,mask][s]
        nnvecr[Hmask[i],0] = nnconf.nnvecr[Hmask][i,mask][s]
        mask = tp == Ht
        s = np.argsort(nnconf.nnr[Hmask][i,mask])[0]
        nnl[Hmask[i],1]    = nnconf.nnl[Hmask][i,mask][s]
        nntype[Hmask[i],1] = nnconf.nntype[Hmask][i,mask][s]
        nnr[Hmask[i],1]    = nnconf.nnr[Hmask][i,mask][s]
        nnvecr[Hmask[i],1] = nnconf.nnvecr[Hmask][i,mask][s]

    #over writing
    #print(nnl)
    nnconf.nnn[:]       = 2
    nnconf.maxnn        = 2
    nnconf.mult_per_img = False
    nnconf.nnl          = nnl
    nnconf.nntype       = nntype
    nnconf.nnr          = nnr
    nnconf.nnvecr       = nnvecr

def get_Descriptor(settings,glob,configuration,h):
    r'''
    This routine calculates the normalized weighted local configurations (descriptors) :math:`\hat{\textbf{X}}_i` which
    descibe the local enviroment arrount an atom using :math:`c^{iJ}_{n00}` and :math:`p^{iJJ'}_{nn'l}`
    
    .. math:: \textbf{X}_i&=\begin{pmatrix}c^{i1}_1 \\ c^{i1}_2 \\\vdots \\ c^{i2}_1 \\c^{i2}_2 \\\vdots \\ p^{i11}_{110} \\ p^{i11}_{111} \\ \vdots \\ p^{i11}_{120} \\ p^{i11}_{121} \\\vdots \\p^{i12}_{110} \\ \vdots \\ p^{i22}_{110} \\ \vdots \end{pmatrix}
    
    Also the deriverive of the weighted local configurations is computed.
    
    Arguments
    ---------
    settings : Setup
        Class containing all the user defined settings for training the MLFF
    glob : Globals
        Class containing all precomputet coefficients
    configuration : Configuration
        An atomic configuration
    h : CubicSpline
        Cubic spline function generated by :func:`polipy4vasp.splines.get_splines`
        
    Returns
    -------
    descriptor : Descriptor
        Class containing the local configuration, its derivertive, and all necercery information for unraveling the data structure
    '''
    llc = None
    nnconf = conf2nn_conf(configuration,settings.Rcut)
    #nnconf_H2O(nnconf)
    cTilde, dcTilde = get_cTilde(settings,nnconf,h)
    c, dc, self_dc, nndo = get_c(settings,nnconf,cTilde,dcTilde)
    do = [nnconf.centraltype == J for J in range(nnconf.maxtype)]
    if settings.lamb == None :
        p, dp = get_p(settings,glob,nnconf,c)
        c = c[:,0,:,:]
        c = np.moveaxis(c.reshape(-1, nnconf.natom), 0, -1)
        p = np.moveaxis(p.reshape(-1, nnconf.natom), 0, -1)
        lc = np.hstack((settings.Beta[0]*c, settings.Beta[1]*p))
        dp = [dp[:,:,:,d] for d in do]
        lc = [lc[d] for d in do]
    else :
        p, dp = get_ten_p(settings,glob,nnconf,c)
        lc = np.moveaxis(p.reshape(2*settings.lamb+1,-1, nnconf.natom), 1, 2)
        dp = [dp[:,:,:,:,:,d] for d in do]
        lc = [lc[:,d] for d in do]
        if settings.Zeta > 1 :
            llc = np.moveaxis(get_p(settings,glob,nnconf,c)[0].reshape(-1, nnconf.natom), 0, -1)
            llc = [llc[d] for d in do]
    return Descriptor(lc = lc,
                      dc = [dc[:,:,d] for d in do],
                      self_dc= [self_dc[:,:,:,d] for d in do],
                      dp = dp,
                      natom = nnconf.natom,
                      centraltype = do,
                      derivtype = nndo,
                      derivl = nnconf.nnl,
                      derivloc = nnconf.nnn,
                      maxderiv = nnconf.maxnn,
                      maxtype = nnconf.maxtype,
                      llc = llc)
        

def get_AllDescriptors(settings,glob,configurations,h):
    r'''
    This routine calculates all the normalized weighted local configurations (descriptors) :math:`\hat{\textbf{X}}_i` which
    descibe the local enviroment arrount an atom. Also the deriverive of the weighted local configurations are computed. 
    
    Arguments
    ---------
    settings : Setup
        Class containing all the user defined settings for training the MLFF
    glob : Globals
        Class containing all precomputet coefficients
    configurations : list
        list containing multible atomic configuration
    h : CubicSpline
        Cubic spline function generated by :func:`polipy4vasp.splines.get_splines`
        
    Returns
    -------
    descriptors : list
        List containing all the local configuration, its derivertive, and all necercery information for unraveling the data structure
    '''
    return [get_Descriptor(settings,glob,conf,h) for conf in configurations]
    #return Parallel(n_jobs=settings.ncore,require='sharedmem')(delayed(get_Descriptor)(settings,glob,conf,h,weights) for conf in configurations)
